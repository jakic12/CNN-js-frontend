!function(t){var e={};function r(s){if(e[s])return e[s].exports;var a=e[s]={i:s,l:!1,exports:{}};return t[s].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.m=t,r.c=e,r.d=function(t,e,s){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var a in t)r.d(s,a,function(e){return t[e]}.bind(null,a));return s},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){const{CNN:s}=r(1);self.addEventListener("message",t=>{if(t.data.cmd){if("confusionMatrix"===t.data.cmd){const e=new s(JSON.parse(t.data.network)).confusionMatrix(t.data.dataset);self.postMessage({event:"confusionMatrix",data:e})}}else{const e=new s(JSON.parse(t.data.network)),r=(t,r)=>{self.postMessage({event:t,data:r,network:JSON.stringify(e)})};e.sgd(Object.assign(t.data.trainingProps,{onProgress:(...t)=>r("batchProgress",t),onEnd:(...t)=>r("end",t)}))}})},function(t,e,r){"use strict";var{matrixMultiply:s,matrixDot:a,transpose:h,convolute:i,doubleInverse:n,correlate:l,getDimension:o,maxPool:p,flattenDeep:f,matrixAdd:d,deepMap:u,backPropagateCorrelation:g,update2Dmatrix:c,maxIndex:y,sum:w}=r(2);const m=t=>1/(1+Math.exp(-t)),N={RELU:{norm:t=>t>0?t:0,derivative:t=>t>0?1:0},SIGMOID:{norm:m,derivative:t=>m(t)*(1-m(t))},TANH:{norm:Math.tanh,derivative:t=>1-Math.pow(Math.tanh(t),2)}};class A{constructor(t){if(t.shape)A.confirmShape(t.shape),this.initialShape=t.initialShape.map(t=>Object.assign({},t)),this.shape=A.applyActivationFunctionToShape(t.initialShape),this.errorF=(t,e)=>Math.pow(e-t,2)/2,this.dErrorF=(t,e)=>e-t,this.learningRate=t.learningRate,this.layers=t.layers,this.dlayers=t.dlayers,this.weights=t.weights,this.biases=t.biases;else{A.confirmShape(t),this.initialShape=t.map(t=>Object.assign({},t)),this.shape=A.applyActivationFunctionToShape(t);const e=(t,e)=>Math.random()*Math.sqrt(6/(t+e)),r=(t,e)=>(2*Math.random()-1)*Math.sqrt(2/t),s=()=>0;this.errorF=(t,e)=>Math.pow(e-t,2)/2,this.dErrorF=(t,e)=>e-t,this.learningRate=-.01,this.layers=new Array(t.length).fill(0).map((e,r)=>t[r].type==O.FC||t[r].type==O.FLATTEN?new Array(t[r].l).fill(0):new Array(t[r].d).fill(0).map(()=>new Array(t[r].h).fill(0).map(()=>new Array(t[r].w).fill(0)))),this.dlayers=[],this.weights=new Array(t.length).fill(0).map((s,a)=>{if(0!=a){if(t[a].type==O.FC)return new Array(t[a-1].l).fill(0).map(()=>new Array(t[a].l).fill(0).map(r=>e(t[a-1].l,t[a].l)));if(t[a].type==O.CONV)return new Array(t[a].k).fill(0).map(()=>new Array(t[a-1].d).fill(0).map(()=>new Array(t[a].f).fill(0).map(()=>new Array(t[a].f).fill(0).map((e,s)=>r(t[a-1].w*t[a-1].d*t[a-1].h)))))}}),this.biases=new Array(t.length).fill(0).map((e,r)=>{if(0!=r)return t[r].type==O.FC?new Array(this.shape[r].l).fill(0).map(s):new Array(this.shape[r].d).fill(0).map(s)})}}static applyActivationFunctionToShape(t){return t.map(t=>t.afName?Object.assign(t,{af:N[t.afName].norm,daf:N[t.afName].derivative}):t)}sgd({dataset:t,epochs:e,learningRate:r=this.learningRate,decay:s=0,onProgress:a,onEnd:h}){this.learningRate=r;for(let h=0;h<e;h++){let e=0,i=0;for(let r=0;r<t.length;r++){let s=this.forwardPropagate(t[r].input);this.backpropagate(t[r].output),this.updateWeights(),e+=this.getError(t[r].output),y(s)===y(t[r].output)&&i++}a&&a(h,i/t.length,e/t.length,this.learningRate),this.learningRate=r/(1+s*h)}h&&h()}confusionMatrix(t){const e=this.layers[this.layers.length-1].length,r=new Array(e).fill(0).map(()=>new Array(e).fill(0));for(let e=0;e<t.length;e++){const s=this.forwardPropagate(t[e].input);t[e].output.length?r[y(t[e].output)][y(s)]++:r[t[e].output][y(s)]++}return r}static confusionMatrixStats(t){const e=t.length,r={actual:[]},s={precision:0,recall:0,f1Score:0};for(let a=0;a<e;a++){const e=t[a][a]/w(t.map(t=>t[a])),h=t[a][a]/w(t[a]);r.actual[a]={precision:e,recall:h,f1Score:e*h*2/(e+h)},s.precision+=r.actual[a].precision,s.recall+=r.actual[a].recall,s.f1Score+=r.actual[a].f1Score}return r.avg={precision:s.precision/e,recall:s.recall/e,f1Score:s.f1Score/e},r}forwardPropagate(t){if(t.length!=this.shape[0].d)throw new Error(`data depth (${t.length}) doesnt match required depth (${this.shape[0].d})`);if(t[0].length!=this.shape[0].h)throw new Error(`data height (${t[0].length}) doesnt match required height (${this.shape[0].h})`);if(t[0][0].length!=this.shape[0].w)throw new Error(`data width (${t[0][0].length}) doesnt match required width (${this.shape[0].w})`);this.layers[0]=t;for(let t=1;t<this.shape.length;t++){switch(this.shape[t].type){case O.CONV:this.layers[t]=l(this.layers[t-1],this.weights[t],this.shape[t].s,this.shape[t].p,this.biases[t]);break;case O.POOL:this.layers[t]=p(this.layers[t-1],this.shape[t].f,this.shape[t].s);break;case O.FLATTEN:this.layers[t]=f(this.layers[t-1]);break;case O.FC:this.layers[t]=d(a([this.layers[t-1]],this.weights[t])[0],this.biases[t])}u(this.layers[t],(t,e,r)=>{if(isNaN(t))throw new Error(`[${e}] output NaN before activation`);return t}),this.shape[t].af&&(this.layers[t]=u(this.layers[t],e=>this.shape[t].af(e))),u(this.layers[t],e=>{if(isNaN(e))throw new Error(`[${t}] output NaN after activation`);return e})}return this.layers[this.layers.length-1]}getError(t,e=!1){if(t.length!=this.shape[this.shape.length-1].l)throw new Error(`expected array length (${t.length}) doesn't equal last layer length (${this.shape[this.shape.length-1].l})`);let r=this.layers[this.shape.length-1].map((e,r)=>this.errorF(t[r],e));return this.error=r.reduce((t,e)=>t+e,0)/this.layers[this.shape.length-1].length,e?r:this.error}backpropagate(t,e=!1){if(t.length!=this.shape[this.shape.length-1].l)throw new Error(`expected array length (${t.length}) doesn't equal last layer length (${this.shape[this.shape.length-1].l})`);for(let r=this.shape.length-1;r>0;r--){if(this.shape[r].type==O.FC){if(r==this.shape.length-1?this.dlayers[r]=this.layers[r].map((e,r)=>this.dErrorF(t[r],e)):this.dlayers[r]=a([this.dlayers[r+1]],h(this.weights[r+1]))[0],this.shape[r].daf&&(this.dlayers[r]=s(this.dlayers[r],u(this.layers[r],t=>this.shape[r].daf(t)))),e)for(let t=0;t<this.weights[r].length;t++)for(let e=0;e<this.weights[r][t].length;e++)this.weights[r][t][e]+=this.layers[r-1][t]*this.dlayers[r][e]*this.learningRate}else if(this.shape[r].type==O.FLATTEN){let e;e=r==this.shape.length-1?this.layers[r].map((e,r)=>this.dErrorF(t[r],e)):a([this.dlayers[r+1]],h(this.weights[r+1]))[0],this.shape[r+1].daf&&(e=s(e,u(this.layers[r],t=>this.shape[r+1].daf(t)))),this.dlayers[r]=e,this.dlayers[r-1]=new Array(this.shape[r].d).fill(0).map((t,s)=>new Array(this.shape[r].h).fill(0).map((t,a)=>new Array(this.shape[r].w).fill(0).map((t,h)=>e[s*this.shape[r].h*this.shape[r].w+a*this.shape[r].h+h])))}else if(this.shape[r].type==O.CONV){const t=g(this.weights[r],this.dlayers[r],this.layers[r-1],this.shape[r].s,this.shape[r].p),{dF:a,dI:h,dB:i}=t;this.dlayers[r-1]=h,this.shape[r].daf&&(this.dlayers[r-1]=s(this.dlayers[r-1],u(this.layers[r-1],t=>this.shape[r].daf(t)))),e&&(this.weights[r]=c(this.weights[r],a,this.learningRate)),e&&(this.biases[r]=this.biases[r].map((t,e)=>t+i[e]*this.learningRate))}else if(this.shape[r].type==O.POOL){let t=new Array(this.shape[r-1].d).fill(0).map(()=>new Array(this.shape[r-1].h).fill(0).map(()=>new Array(this.shape[r-1].w).fill(0))),e=p(this.layers[r-1],this.shape[r].f,this.shape[r].s,!0);for(let s=0;s<this.shape[r].d;s++)for(let a=0;a<this.shape[r].h;a++)for(let h=0;h<this.shape[r].w;h++){let i=e[s][a][h];t[s][i.y][i.x]=this.dlayers[r][s][a][h]}this.dlayers[r-1]=t,this.shape[r].daf&&(this.dlayers[r-1]=s(this.dlayers[r-1],u(this.layers[r-1],t=>this.shape[r].daf(t))))}u(this.dlayers[r],t=>{if(isNaN(t))throw new Error(`[${r}] output ${t} after derivation`);return t})}}updateWeights(){for(let t=this.shape.length-1;t>0;t--)if(this.shape[t].type==O.FC)for(let e=0;e<this.weights[t].length;e++)for(let r=0;r<this.weights[t][e].length;r++)this.weights[t][e][r]+=this.layers[t-1][e]*this.dlayers[t][r]*this.learningRate,this.dlayers[t][r]=0;else if(this.shape[t].type==O.CONV){const e=g(this.weights[t],this.dlayers[t],this.layers[t-1],this.shape[t].s,this.shape[t].p),{dF:r,dI:s,dB:a}=e;this.weights[t]=c(this.weights[t],r,this.learningRate),this.biases[t]=this.biases[t].map((t,e)=>t+a[e]*this.learningRate)}}static confirmShape(t){if(t[0].type!=O.INPUT)throw new Error("the first layer isn't an input layer, instead is: "+t[0].type);for(let e=1;e<t.length;e++)if(t[e].type==O.CONV){if(t[e].w!=(t[e-1].w-t[e].f+2*t[e].p)/t[e].s+1)throw new Error(`[${e}] CONV: outW doesn't equal to calculated outW expected: ${(t[e-1].w-t[e].f+2*t[e].p)/t[e].s+1}, actual: ${t[e].w}`);if(t[e].h!=(t[e-1].h-t[e].f+2*t[e].p)/t[e].s+1)throw new Error(`[${e}] CONV: outH doesn't equal to calculated outH expected: ${(t[e-1].h-t[e].f+2*t[e].p)/t[e].s+1}, actual: ${t[e].h}`);if(t[e].d!=t[e].k)throw new Error(`[${e}] CONV: number of kernels doesn't equal outD kernels: ${t[e].k}, outD: ${t[e].d}`)}else if(t[e].type==O.POOL){if(t[e].w!=(t[e-1].w-t[e].f)/t[e].s+1)throw new Error(`[${e}] POOL: outW doesn't equal to calculated outW expected: ${(t[e-1].w-t[e].f)/t[e].s+1}, actual: ${t[e].w}`);if(t[e].h!=(t[e-1].h-t[e].f)/t[e].s+1)throw new Error(`[${e}] POOL: outH doesn't equal to calculated outH expected: ${(t[e-1].h-t[e].f)/t[e].s+1}, actual: ${t[e].h}`);if(t[e-1].d!=t[e].d)throw new Error(`[${e}] POOL: outD doesn't equal inZ inZ: ${t[e-1].d}, outD: ${t[e].d}`)}else if(t[e].type==O.FC){if(t[e-1].type!=O.FC&&t[e-1].type!=O.FLATTEN)throw new Error(`[${e}] FC: The previous layer should be type FC or FLATTEN`)}else if(t[e].type==O.FLATTEN&&(t[e-1].type==O.FLATTEN||t[e-1].type==O.FC))throw new Error(`[${e}] FLATTEN: The previous layer can't be flat`);return!0}}const O={CONV:0,POOL:1,FC:2,INPUT:3,FLATTEN:4},T={RELU:"RELU",SIGMOID:"SIGMOID",TANH:"TANH"},E={INPUT:function(t,e,r){this.type=O.INPUT,this.w=t,this.h=e,this.d=r},CONV:function(t,e,r,s,a,h,i,n){this.type=O.CONV,this.w=t,this.h=e,this.d=r,this.f=s,this.k=a,this.s=h,this.p=i,this.afName=n},POOL:function(t,e,r,s,a,h){this.type=O.POOL,this.w=t,this.h=e,this.d=r,this.f=s,this.s=a,this.afName=h},FC:function(t,e){this.type=O.FC,this.l=t,this.afName=e},FLATTEN:function(t,e,r){this.type=O.FLATTEN,this.w=t,this.h=e,this.d=r,this.l=t*e*r}},b={LeNet5:[new E.INPUT(32,32,1),new E.CONV(28,28,6,5,6,1,0,T.TANH),new E.POOL(14,14,6,2,2,T.TANH),new E.CONV(10,10,16,5,16,1,0,T.TANH),new E.POOL(5,5,16,2,2,T.TANH),new E.CONV(1,1,120,5,120,1,0,T.TANH),new E.FLATTEN(1,1,120),new E.FC(84,T.TANH),new E.FC(10,T.TANH)],LeNet5Color:[new E.INPUT(32,32,3),new E.CONV(28,28,6,5,6,1,0,T.TANH),new E.POOL(14,14,6,2,2,T.TANH),new E.CONV(10,10,16,5,16,1,0,T.TANH),new E.POOL(5,5,16,2,2,T.TANH),new E.CONV(1,1,120,5,120,1,0,T.TANH),new E.FLATTEN(1,1,120),new E.FC(84,T.TANH),new E.FC(10,T.TANH)]};t.exports={CNN:A,ActivationFunction:T,Layer:E,NetworkArchitectures:b,LayerType:O}},function(t,e){const r=t=>{const e=(t,r)=>t.length?e(t[0],r+1):r;return e(t,0)},s=(t,e)=>t.map((t,r,a)=>t&&t.length?s(t,e):e(t,r,a)),a=(t,e)=>{if(t.length!=e.length)throw new Error("invalid dimensions, both arrays should have equal shape");if(t[0]instanceof Array&&e[0]instanceof Array){const r=[];for(let s=0;s<t.length;s++)r[s]=a(t[s],e[s]);return r}if(t[0]instanceof Array!=e[0]instanceof Array)throw new Error("invalid dimensions, both arrays should have equal shape");{const r=[];for(let s=0;s<t.length;s++)r[s]=t[s]*e[s];return r}},h=(t,e)=>{if(t.length!=e.length)throw new Error("invalid dimensions, both arrays should have equal shape");if(t[0]instanceof Array&&e[0]instanceof Array){const r=[];for(let s=0;s<t.length;s++)r[s]=h(t[s],e[s]);return r}if(t[0]instanceof Array!=e[0]instanceof Array)throw new Error("invalid dimensions, both arrays should have equal shape");{const r=[];for(let s=0;s<t.length;s++)r[s]=t[s]+e[s];return r}},i=t=>{if(1==r(t))return i([[[t]]])[0][0][0];if(2==r(t))return i([[t]])[0][0];if(3==r(t))return i([t])[0];{const e=[];for(let r=0;r<t.length;r++){e[r]=[];for(let s=0;s<t[r].length;s++){e[r][s]=[];for(let a=0;a<t[r][s].length;a++){e[r][s][a]=[];for(let h=0;h<t[r][s][a].length;h++)e[r][s][a][h]=t[r][s][t[r][s].length-a-1][t[r][s][a].length-h-1]}}}return e}},n=(t,e,r=1,s=0,a=null)=>{if(e[0].length!=t.length)throw new Error(`filter depth(${e[0].length}) doesnt match input depth(${t.length})`);if(e[0][0].length!=e[0][0][0].length)throw new Error(`filter should be a square matrix(${e[0][0].length} != ${e[0][0][0].length})`);if(a&&a.length!=e.length)throw new Error(`bias depth(${a.length}), should match output depth(${e.length})`);const h=e[0][0].length,i=t.length,n=parseInt((t[0].length-h+2*s)/r+1),l=parseInt((t[0][0].length-h+2*s)/r+1);return e.map((e,o)=>{const p=[];for(let f=0;f<n;f++){p[f]=[];for(let n=0;n<l;n++){let l=a?a[o]:0;for(let a=0;a<i;a++)for(let i=0;i<h;i++)for(let o=0;o<h;o++){const h=f*r+i-s,p=n*r+o-s;h>=0&&h<t[0].length&&p>=0&&p<t[0][0].length&&(l+=t[a][h][p]*e[a][i][o])}p[f][n]=l}}return p})},l=t=>{let e=-1/0;return s(t,t=>{t>e&&(e=t)}),e},o=t=>{let e=0;return s(t,t=>{e+=t}),e},p=(t,e,r)=>t.map((s,a)=>s&&s.length?p(t[a],e[a],r):t[a]+e[a]*r),f=t=>t.reduce((t,e)=>e.length?t.concat(f(e)):t.concat(e),[]),d=t=>t.map(t=>t instanceof Array?d(t):0);t.exports={matrixMultiply:a,matrixDot:(t,e)=>{if(t[0].length!=e.length)throw new Error(`invalid dimensions a -> x (${t[0].length}) should equal b -> y (${e.length})`);const r=[];for(let s=0;s<t.length;s++){r[s]=[];for(let a=0;a<e[0].length;a++){r[s][a]=0;for(let h=0;h<t[s].length;h++)r[s][a]+=t[s][h]*e[h][a]}}return r},transpose:t=>{if(r(t)>2)throw new Error("transpose supports up to 2d arrays");t[0].length||(t=[t]);const e=[];for(let r=0;r<t[0].length;r++){e[r]=[];for(let s=0;s<t.length;s++)e[r][s]=t[s][r]}return e},convolute:(t,e,r=1,s=0,a=null)=>n(t,i(e),r,s,a),doubleInverse:i,correlate:n,getDimension:r,maxPool:(t,e,s,a=!1)=>{if(3==r(t))return t.map(t=>{const r=(t.length-e)/s+1,h=(t[0].length-e)/s+1;let i=[];for(let n=0;n<r;n++){i[n]=[];for(let r=0;r<h;r++){let h=t[n*s][r*s],l={x:r*s,y:n*s};for(let a=0;a<e;a++)for(let i=0;i<e;i++){let e=n*s+a,o=r*s+i;t[e][o]>h&&(h=t[e][o],l={x:o,y:e})}i[n][r]=a?l:h}}return i});throw new Error(`invalid array dimension (${r(t)}), should be 3`)},flattenDeep:f,matrixAdd:h,deepMap:s,backPropagateCorrelation:(t,e,s,a,h)=>{if(3==r(s)&&4==r(t)){if(t[0].length!=s.length)throw new Error("filter depth doesnt match input depth");const r=[];for(let i=0;i<t.length;i++){r[i]=[];for(let n=0;n<t[i].length;n++){r[i][n]=[];for(let l=0;l<t[i][n].length;l++){r[i][n][l]=new Array(t[i][n][l].length).fill(0);for(let o=0;o<t[i][n][l].length;o++)for(let t=0;t<e[i].length;t++)for(let p=0;p<e[i][t].length;p++){const f=t*a+h+l,d=p*a+h+o;f>=0&&f<s[n].length&&d>=0&&d<s[n][f].length&&(r[i][n][l][o]+=e[i][t][p]*s[n][f][d])}}}}const i=[];for(let r=0;r<t.length;r++)for(let n=0;n<s.length;n++){i[n]=[];for(let l=0;l<s[n].length;l++){i[n][l]=new Array(s[n][l].length).fill(0);for(let o=0;o<s[n][l].length;o++)for(let s=0;s<e[r].length;s++)for(let p=0;p<e[r][s].length;p++){const f=l-s*a+h,d=o-p*a+h;i[n][l]||(i[n][l]=[]),f>=0&&f<t[r][n].length&&d>=0&&d<t[r][n][f].length&&(i[n][l][o]+=e[r][s][p]*t[r][n][f][d])}}}return{dF:r,dI:i,dB:e.map(t=>o(t))}}throw new Error(`invalid array dimension (${r(s)}, ${r(t)})`)},update2Dmatrix:p,max:l,sum:o,softmax:t=>{const e=o(t);return s(t,t=>t/e)},maxIndex:t=>{if(1==r(t)){let e=t[0],r=0;for(let s=1;s<t.length;s++)t[s]>e&&(e=t[s],r=s);return r}throw new Error("maxIndex works only on 1d arrays")},deepNormalize:(t,e)=>(e||(e=l(t)),s(t,t=>t/e)),vectorize:(t,e)=>{const r=new Array(e).fill(0);return r[t]=1,r},deepCopyArrayShape:d}}]);