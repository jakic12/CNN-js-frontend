/* eslint no-restricted-globals: 1 */
// prettier-ignore
!function(t){var e={};function r(s){if(e[s])return e[s].exports;var h=e[s]={i:s,l:!1,exports:{}};return t[s].call(h.exports,h,h.exports,r),h.l=!0,h.exports}r.m=t,r.c=e,r.d=function(t,e,s){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var h in t)r.d(s,h,function(e){return t[e]}.bind(null,h));return s},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){const{CNN:s}=r(1);self.addEventListener("message",t=>{const e=new s(JSON.parse(t.data.network)),r=(...t)=>{self.postMessage({event:"batchProgress",data:t,network:JSON.stringify(e)})};e.sgd(Object.assign(t.data.trainingProps,{onProgress:r,onEnd:r}))})},function(t,e,r){"use strict";var{matrixMultiply:s,matrixDot:h,transpose:a,convolute:i,doubleInverse:n,correlate:l,getDimension:o,maxPool:p,flattenDeep:f,matrixAdd:d,deepMap:g,backPropagateCorrelation:u,update2Dmatrix:y,maxIndex:w}=r(2);const c=t=>1/(1+Math.exp(-t)),m={RELU:{norm:t=>t>0?t:0,derivative:t=>t>0?1:0},SIGMOID:{norm:c,derivative:t=>c(t)*(1-c(t))},TANH:{norm:Math.tanh,derivative:t=>1-Math.pow(Math.tanh(t),2)}};class N{constructor(t){if(t.shape)N.confirmShape(t.shape),this.initialShape=t.initialShape.map(t=>Object.assign({},t)),this.shape=N.applyActivationFunctionToShape(t.initialShape),this.errorF=(t,e)=>Math.pow(e-t,2)/2,this.dErrorF=(t,e)=>e-t,this.learningRate=t.learningRate,this.layers=t.layers,this.dlayers=t.dlayers,this.weights=t.weights,this.biases=t.biases;else{N.confirmShape(t),this.initialShape=t.map(t=>Object.assign({},t)),this.shape=N.applyActivationFunctionToShape(t);const e=(t,e)=>Math.random()*Math.sqrt(6/(t+e)),r=(t,e)=>(2*Math.random()-1)*Math.sqrt(2/t),s=()=>0;this.errorF=(t,e)=>Math.pow(e-t,2)/2,this.dErrorF=(t,e)=>e-t,this.learningRate=-.01,this.layers=new Array(t.length).fill(0).map((e,r)=>t[r].type==A.FC||t[r].type==A.FLATTEN?new Array(t[r].l).fill(0):new Array(t[r].d).fill(0).map(()=>new Array(t[r].h).fill(0).map(()=>new Array(t[r].w).fill(0)))),this.dlayers=[],this.weights=new Array(t.length).fill(0).map((s,h)=>{if(0!=h){if(t[h].type==A.FC)return new Array(t[h-1].l).fill(0).map(()=>new Array(t[h].l).fill(0).map(r=>e(t[h-1].l,t[h].l)));if(t[h].type==A.CONV)return new Array(t[h].k).fill(0).map(()=>new Array(t[h-1].d).fill(0).map(()=>new Array(t[h].f).fill(0).map(()=>new Array(t[h].f).fill(0).map((e,s)=>r(t[h-1].w*t[h-1].d*t[h-1].h)))))}}),this.biases=new Array(t.length).fill(0).map((e,r)=>{if(0!=r)return t[r].type==A.FC?new Array(this.shape[r].l).fill(0).map(s):new Array(this.shape[r].d).fill(0).map(s)})}}static applyActivationFunctionToShape(t){return t.map(t=>t.af?Object.assign(t,{af:m[t.af].norm,daf:m[t.af].derivative}):t)}sgd({dataset:t,epochs:e,learningRate:r=this.learningRate,decay:s=0,onProgress:h,onEnd:a}){this.learningRate=r;for(let a=0;a<e;a++){let e=0,i=0;for(let r=0;r<t.length;r++){let s=this.forwardPropagate(t[r].input);this.backpropagate(t[r].output),this.updateWeights(),e+=this.getError(t[r].output),w(s)===w(t[r].output)&&i++}h&&h(a,i/t.length,e/t.length,this.learningRate),this.learningRate=r/(1+s*a)}a&&a()}forwardPropagate(t){if(t.length!=this.shape[0].d)throw new Error(`data depth (${t.length}) doesnt match required depth (${this.shape[0].d})`);if(t[0].length!=this.shape[0].h)throw new Error(`data height (${t[0].length}) doesnt match required height (${this.shape[0].h})`);if(t[0][0].length!=this.shape[0].w)throw new Error(`data width (${t[0][0].length}) doesnt match required width (${this.shape[0].w})`);this.layers[0]=t;for(let t=1;t<this.shape.length;t++){switch(this.shape[t].type){case A.CONV:this.layers[t]=l(this.layers[t-1],this.weights[t],this.shape[t].s,this.shape[t].p,this.biases[t]);break;case A.POOL:this.layers[t]=p(this.layers[t-1],this.shape[t].f,this.shape[t].s);break;case A.FLATTEN:this.layers[t]=f(this.layers[t-1]);break;case A.FC:this.layers[t]=d(h([this.layers[t-1]],this.weights[t])[0],this.biases[t])}g(this.layers[t],(t,e,r)=>{if(isNaN(t))throw new Error(`[${e}] output NaN before activation`);return t}),this.shape[t].af&&(this.layers[t]=g(this.layers[t],e=>this.shape[t].af(e))),g(this.layers[t],e=>{if(isNaN(e))throw new Error(`[${t}] output NaN after activation`);return e})}return this.layers[this.layers.length-1]}getError(t,e=!1){if(t.length!=this.shape[this.shape.length-1].l)throw new Error(`expected array length (${t.length}) doesn't equal last layer length (${this.shape[this.shape.length-1].l})`);let r=this.layers[this.shape.length-1].map((e,r)=>this.errorF(t[r],e));return this.error=r.reduce((t,e)=>t+e,0)/this.layers[this.shape.length-1].length,e?r:this.error}backpropagate(t,e=!1){if(t.length!=this.shape[this.shape.length-1].l)throw new Error(`expected array length (${t.length}) doesn't equal last layer length (${this.shape[this.shape.length-1].l})`);for(let r=this.shape.length-1;r>0;r--){if(this.shape[r].type==A.FC){if(r==this.shape.length-1?this.dlayers[r]=this.layers[r].map((e,r)=>this.dErrorF(t[r],e)):this.dlayers[r]=h([this.dlayers[r+1]],a(this.weights[r+1]))[0],this.shape[r].daf&&(this.dlayers[r]=s(this.dlayers[r],g(this.layers[r],t=>this.shape[r].daf(t)))),e)for(let t=0;t<this.weights[r].length;t++)for(let e=0;e<this.weights[r][t].length;e++)this.weights[r][t][e]+=this.layers[r-1][t]*this.dlayers[r][e]*this.learningRate}else if(this.shape[r].type==A.FLATTEN){let e;e=r==this.shape.length-1?this.layers[r].map((e,r)=>this.dErrorF(t[r],e)):h([this.dlayers[r+1]],a(this.weights[r+1]))[0],this.shape[r+1].daf&&(e=s(e,g(this.layers[r],t=>this.shape[r+1].daf(t)))),this.dlayers[r]=e,this.dlayers[r-1]=new Array(this.shape[r].d).fill(0).map((t,s)=>new Array(this.shape[r].h).fill(0).map((t,h)=>new Array(this.shape[r].w).fill(0).map((t,a)=>e[s*this.shape[r].h*this.shape[r].w+h*this.shape[r].h+a])))}else if(this.shape[r].type==A.CONV){const t=u(this.weights[r],this.dlayers[r],this.layers[r-1],this.shape[r].s,this.shape[r].p),{dF:h,dI:a,dB:i}=t;this.dlayers[r-1]=a,this.shape[r].daf&&(this.dlayers[r-1]=s(this.dlayers[r-1],g(this.layers[r-1],t=>this.shape[r].daf(t)))),e&&(this.weights[r]=y(this.weights[r],h,this.learningRate)),e&&(this.biases[r]=this.biases[r].map((t,e)=>t+i[e]*this.learningRate))}else if(this.shape[r].type==A.POOL){let t=new Array(this.shape[r-1].d).fill(0).map(()=>new Array(this.shape[r-1].h).fill(0).map(()=>new Array(this.shape[r-1].w).fill(0))),e=p(this.layers[r-1],this.shape[r].f,this.shape[r].s,!0);for(let s=0;s<this.shape[r].d;s++)for(let h=0;h<this.shape[r].h;h++)for(let a=0;a<this.shape[r].w;a++){let i=e[s][h][a];t[s][i.y][i.x]=this.dlayers[r][s][h][a]}this.dlayers[r-1]=t,this.shape[r].daf&&(this.dlayers[r-1]=s(this.dlayers[r-1],g(this.layers[r-1],t=>this.shape[r].daf(t))))}g(this.dlayers[r],t=>{if(isNaN(t))throw new Error(`[${r}] output ${t} after derivation`);return t})}}updateWeights(){for(let t=this.shape.length-1;t>0;t--)if(this.shape[t].type==A.FC)for(let e=0;e<this.weights[t].length;e++)for(let r=0;r<this.weights[t][e].length;r++)this.weights[t][e][r]+=this.layers[t-1][e]*this.dlayers[t][r]*this.learningRate,this.dlayers[t][r]=0;else if(this.shape[t].type==A.CONV){const e=u(this.weights[t],this.dlayers[t],this.layers[t-1],this.shape[t].s,this.shape[t].p),{dF:r,dI:s,dB:h}=e;this.weights[t]=y(this.weights[t],r,this.learningRate),this.biases[t]=this.biases[t].map((t,e)=>t+h[e]*this.learningRate)}}static confirmShape(t){if(t[0].type!=A.INPUT)throw new Error("the first layer isn't an input layer, instead is: "+t[0].type);for(let e=1;e<t.length;e++)if(t[e].type==A.CONV){if(t[e].w!=(t[e-1].w-t[e].f+2*t[e].p)/t[e].s+1)throw new Error(`[${e}] CONV: outW doesn't equal to calculated outW expected: ${(t[e-1].w-t[e].f+2*t[e].p)/t[e].s+1}, actual: ${t[e].w}`);if(t[e].h!=(t[e-1].h-t[e].f+2*t[e].p)/t[e].s+1)throw new Error(`[${e}] CONV: outH doesn't equal to calculated outH expected: ${(t[e-1].h-t[e].f+2*t[e].p)/t[e].s+1}, actual: ${t[e].h}`);if(t[e].d!=t[e].k)throw new Error(`[${e}] CONV: number of kernels doesn't equal outD kernels: ${t[e].k}, outD: ${t[e].d}`)}else if(t[e].type==A.POOL){if(t[e].w!=(t[e-1].w-t[e].f)/t[e].s+1)throw new Error(`[${e}] POOL: outW doesn't equal to calculated outW expected: ${(t[e-1].w-t[e].f)/t[e].s+1}, actual: ${t[e].w}`);if(t[e].h!=(t[e-1].h-t[e].f)/t[e].s+1)throw new Error(`[${e}] POOL: outH doesn't equal to calculated outH expected: ${(t[e-1].h-t[e].f)/t[e].s+1}, actual: ${t[e].h}`);if(t[e-1].d!=t[e].d)throw new Error(`[${e}] POOL: outD doesn't equal inZ inZ: ${t[e-1].d}, outD: ${t[e].d}`)}else if(t[e].type==A.FC){if(t[e-1].type!=A.FC&&t[e-1].type!=A.FLATTEN)throw new Error(`[${e}] FC: The previous layer should be type FC or FLATTEN`)}else if(t[e].type==A.FLATTEN&&(t[e-1].type==A.FLATTEN||t[e-1].type==A.FC))throw new Error(`[${e}] FLATTEN: The previous layer can't be flat`);return!0}}const A={CONV:0,POOL:1,FC:2,INPUT:3,FLATTEN:4},O={RELU:"RELU",SIGMOID:"SIGMOID",TANH:"TANH"},T={INPUT:function(t,e,r){this.type=A.INPUT,this.w=t,this.h=e,this.d=r},CONV:function(t,e,r,s,h,a,i,n){this.type=A.CONV,this.w=t,this.h=e,this.d=r,this.f=s,this.k=h,this.s=a,this.p=i,this.af=n},POOL:function(t,e,r,s,h,a){this.type=A.POOL,this.w=t,this.h=e,this.d=r,this.f=s,this.s=h,this.af=a},FC:function(t,e){this.type=A.FC,this.l=t,this.af=e},FLATTEN:function(t,e,r){this.type=A.FLATTEN,this.w=t,this.h=e,this.d=r,this.l=t*e*r}},E={LeNet5:[new T.INPUT(32,32,1),new T.CONV(28,28,6,5,6,1,0,O.TANH),new T.POOL(14,14,6,2,2,O.TANH),new T.CONV(10,10,16,5,16,1,0,O.TANH),new T.POOL(5,5,16,2,2,O.TANH),new T.CONV(1,1,120,5,120,1,0,O.TANH),new T.FLATTEN(1,1,120),new T.FC(84,O.TANH),new T.FC(10,O.TANH)],LeNet5Color:[new T.INPUT(32,32,3),new T.CONV(28,28,6,5,6,1,0,O.TANH),new T.POOL(14,14,6,2,2,O.TANH),new T.CONV(10,10,16,5,16,1,0,O.TANH),new T.POOL(5,5,16,2,2,O.TANH),new T.CONV(1,1,120,5,120,1,0,O.TANH),new T.FLATTEN(1,1,120),new T.FC(84,O.TANH),new T.FC(10,O.TANH)]};t.exports={CNN:N,ActivationFunction:O,Layer:T,NetworkArchitectures:E,LayerType:A}},function(t,e){const r=t=>{const e=(t,r)=>t.length?e(t[0],r+1):r;return e(t,0)},s=(t,e)=>t.map((t,r,h)=>t&&t.length?s(t,e):e(t,r,h)),h=(t,e)=>{if(t.length!=e.length)throw new Error("invalid dimensions, both arrays should have equal shape");if(t[0]instanceof Array&&e[0]instanceof Array){const r=[];for(let s=0;s<t.length;s++)r[s]=h(t[s],e[s]);return r}if(t[0]instanceof Array!=e[0]instanceof Array)throw new Error("invalid dimensions, both arrays should have equal shape");{const r=[];for(let s=0;s<t.length;s++)r[s]=t[s]*e[s];return r}},a=(t,e)=>{if(t.length!=e.length)throw new Error("invalid dimensions, both arrays should have equal shape");if(t[0]instanceof Array&&e[0]instanceof Array){const r=[];for(let s=0;s<t.length;s++)r[s]=a(t[s],e[s]);return r}if(t[0]instanceof Array!=e[0]instanceof Array)throw new Error("invalid dimensions, both arrays should have equal shape");{const r=[];for(let s=0;s<t.length;s++)r[s]=t[s]+e[s];return r}},i=t=>{if(1==r(t))return i([[[t]]])[0][0][0];if(2==r(t))return i([[t]])[0][0];if(3==r(t))return i([t])[0];{const e=[];for(let r=0;r<t.length;r++){e[r]=[];for(let s=0;s<t[r].length;s++){e[r][s]=[];for(let h=0;h<t[r][s].length;h++){e[r][s][h]=[];for(let a=0;a<t[r][s][h].length;a++)e[r][s][h][a]=t[r][s][t[r][s].length-h-1][t[r][s][h].length-a-1]}}}return e}},n=(t,e,r=1,s=0,h=null)=>{if(e[0].length!=t.length)throw new Error(`filter depth(${e[0].length}) doesnt match input depth(${t.length})`);if(e[0][0].length!=e[0][0][0].length)throw new Error(`filter should be a square matrix(${e[0][0].length} != ${e[0][0][0].length})`);if(h&&h.length!=e.length)throw new Error(`bias depth(${h.length}), should match output depth(${e.length})`);const a=e[0][0].length,i=t.length,n=parseInt((t[0].length-a+2*s)/r+1),l=parseInt((t[0][0].length-a+2*s)/r+1);return e.map((e,o)=>{const p=[];for(let f=0;f<n;f++){p[f]=[];for(let n=0;n<l;n++){let l=h?h[o]:0;for(let h=0;h<i;h++)for(let i=0;i<a;i++)for(let o=0;o<a;o++){const a=f*r+i-s,p=n*r+o-s;a>=0&&a<t[0].length&&p>=0&&p<t[0][0].length&&(l+=t[h][a][p]*e[h][i][o])}p[f][n]=l}}return p})},l=t=>{let e=-1/0;return s(t,t=>{t>e&&(e=t)}),e},o=t=>{let e=0;return s(t,t=>{e+=t}),e},p=(t,e,r)=>t.map((s,h)=>s&&s.length?p(t[h],e[h],r):t[h]+e[h]*r),f=t=>t.reduce((t,e)=>e.length?t.concat(f(e)):t.concat(e),[]),d=t=>t.map(t=>t instanceof Array?d(t):0);t.exports={matrixMultiply:h,matrixDot:(t,e)=>{if(t[0].length!=e.length)throw new Error(`invalid dimensions a -> x (${t[0].length}) should equal b -> y (${e.length})`);const r=[];for(let s=0;s<t.length;s++){r[s]=[];for(let h=0;h<e[0].length;h++){r[s][h]=0;for(let a=0;a<t[s].length;a++)r[s][h]+=t[s][a]*e[a][h]}}return r},transpose:t=>{if(r(t)>2)throw new Error("transpose supports up to 2d arrays");t[0].length||(t=[t]);const e=[];for(let r=0;r<t[0].length;r++){e[r]=[];for(let s=0;s<t.length;s++)e[r][s]=t[s][r]}return e},convolute:(t,e,r=1,s=0,h=null)=>n(t,i(e),r,s,h),doubleInverse:i,correlate:n,getDimension:r,maxPool:(t,e,s,h=!1)=>{if(3==r(t))return t.map(t=>{const r=(t.length-e)/s+1,a=(t[0].length-e)/s+1;let i=[];for(let n=0;n<r;n++){i[n]=[];for(let r=0;r<a;r++){let a=t[n*s][r*s],l={x:r*s,y:n*s};for(let h=0;h<e;h++)for(let i=0;i<e;i++){let e=n*s+h,o=r*s+i;t[e][o]>a&&(a=t[e][o],l={x:o,y:e})}i[n][r]=h?l:a}}return i});throw new Error(`invalid array dimension (${r(t)}), should be 3`)},flattenDeep:f,matrixAdd:a,deepMap:s,backPropagateCorrelation:(t,e,s,h,a)=>{if(3==r(s)&&4==r(t)){if(t[0].length!=s.length)throw new Error("filter depth doesnt match input depth");const r=[];for(let i=0;i<t.length;i++){r[i]=[];for(let n=0;n<t[i].length;n++){r[i][n]=[];for(let l=0;l<t[i][n].length;l++){r[i][n][l]=new Array(t[i][n][l].length).fill(0);for(let o=0;o<t[i][n][l].length;o++)for(let t=0;t<e[i].length;t++)for(let p=0;p<e[i][t].length;p++){const f=t*h+a+l,d=p*h+a+o;f>=0&&f<s[n].length&&d>=0&&d<s[n][f].length&&(r[i][n][l][o]+=e[i][t][p]*s[n][f][d])}}}}const i=[];for(let r=0;r<t.length;r++)for(let n=0;n<s.length;n++){i[n]=[];for(let l=0;l<s[n].length;l++){i[n][l]=new Array(s[n][l].length).fill(0);for(let o=0;o<s[n][l].length;o++)for(let s=0;s<e[r].length;s++)for(let p=0;p<e[r][s].length;p++){const f=l-s*h+a,d=o-p*h+a;i[n][l]||(i[n][l]=[]),f>=0&&f<t[r][n].length&&d>=0&&d<t[r][n][f].length&&(i[n][l][o]+=e[r][s][p]*t[r][n][f][d])}}}return{dF:r,dI:i,dB:e.map(t=>o(t))}}throw new Error(`invalid array dimension (${r(s)}, ${r(t)})`)},update2Dmatrix:p,max:l,sum:o,softmax:t=>{const e=o(t);return s(t,t=>t/e)},maxIndex:t=>{if(1==r(t)){let e=t[0],r=0;for(let s=1;s<t.length;s++)t[s]>e&&(e=t[s],r=s);return r}throw new Error("maxIndex works only on 1d arrays")},deepNormalize:(t,e)=>(e||(e=l(t)),s(t,t=>t/e)),vectorize:(t,e)=>{const r=new Array(e).fill(0);return r[t]=1,r},deepCopyArrayShape:d}}]);
